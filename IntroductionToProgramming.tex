\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8]{inputenc}

% Title Page
\title{Lectures 1--2: Introduction to Computer Programming and Python}
\author{Andrew D. Wickert}

\usepackage{listings}
\usepackage{framed}
\usepackage{graphicx}
\lstset{mathescape,basicstyle=\ttfamily} % Allow escaping to LaTeX inside $..$

\usepackage{color}
\usepackage[hyphens]{url}
\usepackage[colorlinks=true]{hyperref}
\usepackage[T1]{fontenc}

\newcommand{\todo}[1]{\textcolor{red}{@TODO: #1}} 
 
% From http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings, modified a little

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\scriptsize,          % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Python,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}
\maketitle

\section{Why do we program computers?}

In order to analyze data, run simulations, check the logical consistency of our ideas, and compare models to the real world, we need numbers. Working with numbers requires quite a lot of repetitive calculation. Doing these calculations ourselves is boring, miserable, and saps our very humanity. Fortunately, computers are excellent at doing repeated tasks. Automating a computer to do our ``dirty work'' is what programming is all about. In order to send instructions to the computer, we need to write in a language that obeys rules of unambiguous formal logic. This is a computer programming language.

Over this course, there will be many struggles in making this communication between you and the computer work. Therefore, it is important to remember why we program computers: these reasons include to make our lives easier and more pleasant, to accomplish more than we could without the assistance of a computer, to have a perfectly logical companion who can inform us about the internal consistency of our ideas, and to build a numerical laboratory in which we can develop virtual experiments. If it seems that computers are making our lives harder rather than easier, it is time to take a step back and a deep breath, and evaluate what we are doing and why we are doing it.

\section{How we program computers}

Computer programming languages are a set of commands that we write in human-readable text that eventually are turned into machine-readable binary. This can happen via one of two means:
\begin{itemize}
 \item In a \textbf{compiled language}, we use a program called a ``compiler'' to translate what we have written into machine language. In the past, this was done by hand -- so you can thank your lucky stars for all of the dedicated engineers, mathematicians, programmers, and technicians who have made these compilers that literally tell a computer how to program itself based on your commands to it!
 \item In an \textbf{interpreted language} (or ``scripting language''), your commands are not compiled into byte code (machine language) \textit{en masse}. Rather, they all reference pre-compiled functions. Because of this, you don't have to re-compile the program every time you change it and your coding can be very flexible, but these programs often run somewhat slower than compiled programs. This is the trade-off: ease of programming for you costs computational efficiency in this case.
\end{itemize}

\begin{figure}[h]
\begin{center}
\includegraphics[width=.8\linewidth]{figures/Introduction/Compilervrsinterpreter.JPG}
\end{center}
\caption{Compiltered languages are pre-processed (i.e. compiled) for efficiency for the computer (but not the human!). Interpreted languages are processed at runtime -- one less step for developers (i.e. humans), but more effort for the computer. Image from Aniket Thakur at \url{http://opensourceforgeeks.blogspot.com/2013/03/difference-between-compiler-interpreter.html}.}
\end{figure}

\section{Python and the major programming languages}

In this course, we will learn Python. It is an interpreted, multi-paradigm, multi-purpose, and easy-to-read open-source language. These mean that:
\begin{itemize}
 \item \textbf{Interpreted:} You don't have to compile the code every time you make a change. This helps speed code development and your learning (critical in this course!) at the cost of some computational efficiency (*not* critical in this course).
 \item \textbf{Multi-paradigm:} This means that the language can be written as an \textbf{imperative} language, with a sequence of command that are executed in some defined order, or as an \textbf{object-oriented language}, in which ``objects''---clusters of related variables and functions: think perhaps of a volume of soil that has a temperature and thermal conductivity (variables) and can conduct heat (a function)---are manipulated.
 \item \textbf{Multi-purpose:} Python cam be used for numerical modeling, data analysis, web development, interfacing with peripheral devices, automating tasks in GIS, and much more.
 \item \textbf{Easy-to-read:} As programming languages go, Python can be ``read'' fairly well by someone who has no experience with it.
 \item \textbf{Open-source:} Python is freely available and is updated and expanded by a dedicated community of volunteers. Therefore, learning how to use it will not tie your skills to any software package that must be purchased.
\end{itemize}
Many of these reasons highlight why I have chosen to work with Python for this course. However, it is important to go over a number of the other major programming languages used in the geosciences, at very least such that their names are familiar to you and you will not feel like you are starting from nothing if you have to program in one of them someday. These are:

\begin{figure}
\begin{center}
\begin{tabular}{l|c|c}
 & \textbf{Compiled} & \textbf{Interpreted} \\
\hline
\textbf{Open-source} & \begin{tabular}{@{}c@{}}Fortran \\ C/C++ \\ Java\end{tabular} & \begin{tabular}{@{}c@{}}Python \\ R \\ Octave (Matlab clone)\end{tabular}  \\
\hline
\textbf{Proprietary} & C\# & \begin{tabular}{@{}c@{}}Matlab \\ IDL \end{tabular}
\end{tabular}
\end{center}
\caption{Open-source and proprietary, interpreted and compiled, programming languages. For open-access and ease-of-use, we will be using Python, which is interpreted and open-source.}
\end{figure}

C, C++, and Fortran (f77 and f95) are the most commonly-used compiled programming langauges for scientific computing. These are the true ``heavy lifters'' in computational science. Fortunately, Python is written in C (giving it a native interface with C code), and a compiler called ``f2py'' allows Fortran code to be compiled in such a way that Python can talk to it. Java is occasionally used, but is less developed in the numerical realm.

Many of your colleagues in the general geosciences use Matlab, which is a very similar language, except that it is more focused on matrix operations, data analysis, and scientific computing... and that it is closed-source, meaning that you cannot see how it actually works. Furthermore, you need to purchase a license to use it. For those of you who are familiar with Matlab already, I would suggest the Mathesaurus entry ``Numpy for Matlab Users'' (Numpy is the numerical package for Python) at \url{http://mathesaurus.sourceforge.net/matlab-numpy.html}.

IDL is commonly used by atmospheric scientists as well as the community involved with the ENVI GIS package. However, the other major GIS packages, both proprietary (ArcGIS) and open-source (GRASS GIS and QGIS) use Python as their interface language.

R is a programming language designed to perform statistical analyses. It excels in this field. However, outside of this scope, it is fairly limited, which is why we won't learn it in this course. After learning Python, learning R should be straightforward.

The other reasons to teach you Python are that it has functions that streamline file input and output and can connect easily to programs written in other languages, including compiled langauges, making it an effective language to ``glue'' together pieces of code written in highly efficient (but clunkier to manipulate) C or Fortran code. It also produces excellent graphical outputs. In short, what I am writing that I have chosen Python after thinking long and hard about the decision and using it for an extended period of time myself, and I think that learning it will be a worthwhile use of your time.

\section{Practical interlude: downloading and installing}

\subsection{Python interpreter and development environment}

Now we know that we can write code in Python that can be interpreted into a machine language. Great! So how does that happen?

With an interpreter, of course! You must download and install one onto your computer. Linux/*nix and Mac computers come pre-loaded with a basic Python interpreter, but we will need more packages than that, and the Mac version of the Python interpreter is often not up-to-date. Windows machines generally do not come with Python by default.

While the interpreter changes human-readable text into machine language, it does not help humans produce that human-readable text. This is where a development environment comes in. This is something that will format the text for us to help us follow the flow of the code, automatically complete expressions, and more. There are a two main options to do this:

\begin{itemize}
 \item Command prompt and text editor. In each of these cases, I recommend \textbf{ipython} as the program to execute the Python code at the command line interface (= command prompt). Some examples of combinations of these are:
 \begin{itemize}
  \item Windows: Cygwin and notepad++
  \item Linux: Terminal and gedit
  \item Mac: Terminal and textwrangler
 \end{itemize}
 \item Spyder: a Matlab-like Integrated Development Environment (IDE)
\end{itemize}

Shell and text editor: gedit/notepad++/textwrangler and ipython or Spyder


The Python packages that we will want at the outset of this course are:
\begin{itemize}
 \item The most recent Python 2.*.* (not Python 3.* -- this is a fairly different take on Python that is not connected to the scientific programming packages)
 \item NumPy (\textbf{Num}erical \textbf{Py}thon): a package to handle arrays, matrix operations, and more
 \item SciPy (\textbf{Sci}entific \textbf{Py}thon): a package that contains special functions, interpolation techniques, linear algebra solvers, and other tools that are useful for scientific programming
 \item Matplotlib: a plotting library with an extensive range of applications (see \url{http://matplotlib.org/gallery.html}); we \todo{will} use the map-plotting extensions to matplotlib later in this course.
\end{itemize}

\subsubsection{Linux}

Use your package manager. For Debian/Ubuntu, type at the command line:

\begin{lstlisting}[language=sh]
# Basic packages
sudo apt-get install \
python python-numpy python-scipy \
python-setuptools python-matplotlib 

# pip (recommended for automatic installs via setuptools)
sudo apt-get install python-pip

# iPython console -- very useful (optional)
sudo apt-get install ipython

# Sypder IDE (I don't personally use it but many others like it: optional)
sudo apt-get install spyder
\end{lstlisting}

(The package ``python'' should be installed by default\footnote{Once I was trying to change which version of Python I was using, and without thinking about it (or knowing nearly so much as I do now), I simply typed ``sudo apt-get remove python'' and entered my password and pressed enter. However, had I looked at the screen to see the list of packages that  would also be removed, I would have realized that the list of core functions of my computer that depend on the Python interpreter was enormous. Long story short: had to reboot to a command-line terminal to ``apt-get install'' and put all of the core software back on my computer, just so I could boot to the desktop!}, but is included in this list for completeness.)

\subsubsection{Windows}

Download \textbf{python(x,y)} (\url{https://code.google.com/p/pythonxy/wiki/Downloads}) or another full-featured distribution such as \textbf{Anaconda} (\url{https://store.continuum.io/cshop/anaconda/}). These and several others also contain the required packages (including the numerical libraries), the iPython console, and the Spyder IDE; \textbf{Spyder} (\url{https://code.google.com/p/spyderlib/}) is a nice IDE that will provide a familiar-looking interface for users accustomed to Matlab. 

\begin{framed}
\textbf{Important: those of you with a pre-existing ArcGIS install that comes with its own (albeit more limited) version of Python, you sh Python(x,y) you should install Anaconda. Python(x,y) will not work.} It should be possible to link Arc to your new install of Python, but I am not sure if you will need to re-install Arc to make this work -- this would be recommended if you would like to program with ArcGIS, as you will have a more complete version of Python to use.
\end{framed}

\subsubsection{Mac}

One recommendation is to use a package manager like \textbf{homebrew} (\url{http://brew.sh/}). With this you can install Python, and then move on to using \textbf{pip} (or homebrew) to install the Python modules. A good introduction to this can be found here: \url{http://www.thisisthegreenroom.com/2011/installing-python-numpy-scipy-matplotlib-and-ipython-on-lion}. See the \textbf{Linux} instructions for the list of packages that you will need; after installing pip, these commands can be substituted as follows, e.g.,

\begin{lstlisting}[language=sh]
# Homebrew
sudo brew install python-numpy
# Pip
pip install numpy
\end{lstlisting}

Recent efforts to download Python distributions (both **Anaconda** and **Enthought**) have not met with success with both gFlex and GRASS, though **Anaconda** has been tested successfully with Windows. As a result, it should be more successful to keep the Python packages managed better by something like **homebrew** with **pip**.

\begin{framed}
\textbf{If you do not have Arc and want to do GIS programming, three main options exist.} You may use GRASS GIS (\url{http://grass.osgeo.org/download/}, QGIS \url{https://www.qgis.org/en/site/forusers/download.html}), or simply use the GDAL an OGR libraries with Python.
\end{framed}

\section{Basic Python programming (and programming concepts in general)}

The following sections provide a brief introduction to programming in Python. A more exhaustive treatment can be found in the textbook, \emph{Think Python: How to Think Like a Computer Scientist} (PDF and HTML available at \url{http://www.greenteapress.com/thinkpython/}).

\subsection{So you want to write a program}

By now, you know that a program is a set of user-readable text that the computer can understand and use to drive its actions. Even though at this point you might not be familiar with a program, immersion is a way of learning, so here is a simple program that we will use for examples in the next several sections.

\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

#! /usr/bin/env python

# firstExample.py
# 
# Written by ADW on 05 May 2015
# while finishing these notes at the last minute
# (as usual) to teach class tomorrow
# 
# This program will continue adding numbers to a starting
# value until the number reaches 50.
# It then multiplies this by 2 three times.

import sys

counter = 0 # value to be modified

while counter < 50:
  counter += 1

if counter == 50:
  # It should at this point!
  print "50!"
else:
  print "Error!"
  
for i in range(3):
  # i = [0, 1, 2] (0-indexing)
  counter *= 10

if counter == 50 * 10**3:
  print "Checks out -- done!"
  print "Final counter =", counter
else:
  sys.exit("Fail!")
  
print "Now let's divide counter by 25001, just over half"
print counter/25001

print "Now let's divide counter by 25001., just over half"
print counter/25001.

\end{lstlisting}

Before going any further, I will make a note of a couple of pieces of this code here:
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

#! /usr/bin/env python
\end{lstlisting}
This is the ``shebang''. It is important on Unix-like operating systems (e.g., Linux, Mac) to tell the computer which interpreter to use.

Next,
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

#! /usr/bin/env python

# firstExample.py
# 
# Written by ADW on 05 May 2015
# while finishing these notes at the last minute
# (as usual) to teach class tomorrow
# 
# This program will continue adding numbers to a starting
# value until the number reaches 50.
# It then multiplies this by 2 three times.
\end{lstlisting}
The pound sign (hashtag!), \#, denotes comments. These can be used throughout your code. And they should be used! Many hours of work writing code are often rendered useless when someone else tries to use it only to find no comments among a pile of expressions in a computer language. Even worse, many people have been known to not recognize their own code 6 months or 1 year out unless they have written good comments. Get in a habit of writing many good comments early, and you will be better-off for it.

\begin{framed}
For comments, see Downey, p. 19
\end{framed}

In comments, I typically write the name of the code (in case I change it later -- to remember), the date that I started to write it (and perhaps other dates of significant code development), and my name or initials. I also write a short note about what the program does.

After this, there is ``import'' call.
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

import sys
\end{lstlisting}
``import'' brings in a specific package of extra functions in Python. This is called a ``module''. Eventually, when you write programs, you may create your own modules that are related to the problems that you like to solve. Such a module may relate to, for example, solutions for stress inside the Earth. The module ``sys'', as its name suggests, connects to the computer system. Towards the end of the code,
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

  sys.exit("Fail!")
\end{lstlisting}
causes the program to crash if it is executed. This can be useful to provide an useful message to the user if something is badly wrong. Modules have many helpful functions, most of which do not abruptly terminate the operation!

\subsection{Variables and basic types}

\begin{framed}
See Downey, pp. 13--15
And for more on strings, see Downey, Chapters 8 and 9
\end{framed}

Variables can be things like:
\begin{lstlisting}
a = 152 # Integer (int)
b = 16.2 # "Floating point" number (float)
c = 'Ada Lovelace' # Character string (str)
c2 = "Lord Byron" # double quotes also define a string (str)
d = True # Boolean (bool)
\end{lstlisting}

Each of these four examples with distinct letters is a different variable \textbf{type}, as noted in the comment (\# sign) after each entry. They behave differently. As might be expected, integers and floats play with each other better than do strings. The other important piece in the above code is the use of \textbf{=} as the \emph{assignment operator}. It assigns the value to that particular variable letter. This is quite powerful, as variables can allow a code to be flexible and work with a wide range of input values -- or even input types!

So now, in our above code, we can see that we have defined the variable ``counter'', and that it is an integer.
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

counter = 0 # value to be modified
\end{lstlisting}

What if we had wanted to make it a floating-point number? Well, we simply would put a decimal point after it.
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

counter2 = 0.
\end{lstlisting}

This is important when you want to take advantage of the ways in which integers and floating point numbers differ. See Section \ref{s:math} for a common example of this.

Types apply to all values in a code, whether they are assigned to variables or just added ``on the fly'' to the code.

Boolean values can be \lstinline{True} or \lstinline{False}. These are often used for ``flow control'', or telling your code how to step from one step to another. This is explained further in section \ref{s:loops}.

Additional types for individual values include \lstinline{Null} for non-values and \lstinline{inf} for infinite values.

\section{Letters and numbers: A look from the computer's point of view}

Now that we've talked a bit about different variable types, I might explain why they are important. As we all know, computers record data in binary: 0 and 1. How does this turn into letters and numbers? Well, let's think a bit about how computers store data, because we all are familiar with that from saving files, buying hard drives, etc.

\begin{itemize}
 \item 1 bit can have two values: 0/OFF/FALSE/LOW and 1/ON/TRUE/HIGH. This is the fundamental unit of computation.
 \item 8 bits in one byte
 \item 1024 bytes in one kilobyte (KiB), though note that often a metric convention of 1000 is used for this and later conversions!
 \item 1024 KiB in one megabyte (MiB)
 \item ... and so on.
\end{itemize}

From this we already know that a \lstinline{bool}, which can be \lstinline{True} or \lstinline{False}, is 1 bit! This is really memory-efficient.

Now let's look at the second value. What is special about 8 bits being in one byte? Well, we know that:
\begin{equation}
 2^8 = 256
\end{equation}
Do you remember computers with 256-color displays? Exactly! They were using one byte per pixel to describe the color on the screen.

When using numbers, we like to include zero. So instead of having a list of values that is [1, 2, 3, ..., 255, 256], we have one that is [0, ..., 255]. Does this sound familiar? Like, for example, a color-picker in a photo-editing or illustrating application? We call this an \textbf{unsigned 8-bit integer}. ``Unsigned'' means that it does not have anything to say whether it is positive or negative.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=.8\linewidth]{figures/Introduction/Lsb0.pdf}
\end{center}
\caption{Graphically, a byte can be displayed as a set of 1's and 0's. This shows an example at which the bit numbering starts at the right and goes left, but the more important piece to notice at this stage is just how the different blocks of 1's and 0's can combine to make a larger number, that then can represent something inside the computer.}
\end{figure}

\begin{figure}[!ht]
 \begin{center}
 \includegraphics[width=.8\linewidth]{figures/Introduction/convert-hexadecimal-to-binary-C-.png}
 \end{center}
 \caption{Binary, hexadecimal, and decimal conversion table. From Nitin Kumar, \url{http://www.easycppcodes.com/conversion/program-to-convert-hexadecimal-to-binary-c/}}
\end{figure}

What happens if we want negative numbers? Well, we can choose the sign with one of our bits. But then we have only seven to give the values. Thus, we get a range of $-128$ -- $+127$ for \textbf{signed 8-bit integer}.

8-bit inetegers are also helpful for printing letters. In ASCII, the American Standard Code for Information Interchange, which was first established in 1963, letters, numbers, symbols, and special ``control'' characters are designated by a seven-bit number with the last bit for optional error-checking. (The last bit was optional so it could be dropped to save costs when transmitting even this small amount of data was a big deal -- thus many teletype machines used 7 bits! This chart was published in February 1972.)

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=.8\linewidth]{figures/Introduction/ASCII_Code_Chart-Quick_ref_card.png}
\end{center}
\caption{ASCII is probably the most simple and widely-used method of encoding letters and numbers. It was originally developed in the 1960's for telephone operators for teletype machines; this fa Ever wonder why we can't have umlauts in email addresses? Or why so many people use all flat lines (hyphen, minus sign, and dashes) as the same thing? It's ASCII's fault! But there is only so much one can do with 128 characters.}
\end{figure}

The rules for bytes can then be extrapolated to 16-, 32-, and 64-bit values. These can generate huge integers!

But what about numbers with a decimal place (\lstinline{float}). These ``floating point'' numbers store values in scientific notation, with one bit for the sign, some number of bits for the exponent, and some bits for the value that is then multiplied by 10 to the specified power. You might imagine that this can create rounding errors, as there are infinite numbers but only finite bits in such a representation. And indeed it does: see \emph{What Every Computer Scientist Should Know About Floating-Point Arithmetic} (\url{http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html}) to learn more.

Python handles changes between these types, and the amount of memory required to store them, pretty much automatically. But not all programming languages do, and this is important to know for general programming literacy!

\begin{framed}
For a really nice review of how computers actually work, check out the first answer at \url{http://programmers.stackexchange.com/questions/81624/how-do-computers-work}. Also, you'll become qutie good friends with StackExchange/StackOverflow, as you can do a Google search on literally nearly any problem you may encounter while programming, find someone who already asked the question there, and find the best answer that typically explains what is going on really well. Much of my programming knowledge comes from Internet help, either by directly answering my question, or by giving me some ideas to help reason through it on my own!
\end{framed}

\subsection{Loops: for, while}
\label{s:loops}

Loops repeat execution of a piece of code while a particular condition is met. In the above code:
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

while counter < 50:
  counter += 1
\end{lstlisting}
changes ``counter'' by adding 1 to it so long as ``counter'' is less than 50. Pretty simple right? Well, what if we changed it to this?
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

trouble = True
while trouble == True:
  counter += 1
\end{lstlisting}
``=='' is the logical equals expression; while ``='' assigns values, ``=='' checks for equivalency. Would the prgram ever end?

\begin{framed}
\textbf{The power of CTRL+C (Control+C, Strg+C):} It doesn't just copy text! It forcibly terminates your programs. Very useful for stopping mistakes from getting out of hand. Like infinite loops.
\end{framed}

Would this code create an infinite loop?
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]

trouble = True
while trouble:
  counter += 1
\end{lstlisting}
Here, we are missing the \lstinline{== True} after \lstinline{Trouble}. However, this still works. Why is that? Well, the code simply evaluates whether the statement is nonzero when trying to decide whether to continue the \lstinline{while} loop. Consider \lstinline{while counter < 50} above, for example. An additional helpful piece of information: Boolean \lstinline{True} is 1 (and \lstinline{False} is 0).

Another type of loop is a \lstinline{for} loop, in which the loop runs until you run out of values in a list. For example:
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]
for i in range(3):
  # i = [0, 1, 2] (0-indexing)
  counter *= 10
\end{lstlisting}
\lstinline{range} is a special Python command that creates a set of values that goes up to (but does not exceed) the value inside the parentheses. So, as the comment notes, \lstinline{range(3)} produces \lstinline{[0, 1, 2]}. These square brackets indicate that this is a \lstinline{list}, a variable type that is a container for other values; this is discussed in section \ref{s:containerTypes}.

``Nesting'' is the process of combining multiple for loops. You may use the below space to write an example of nested loops and to write some thoughts about why you might want to do this.

\vspace{6cm}

\subsection{Logical operators and flow control: if, else if, else, and, or, not}

\begin{framed}
 See Chapter 5 in Downey for a much more thorough introduction
\end{framed}

Two portions of the code above use ``if'' and ``else''. This provides ``flow control'' for the code by giving causing events to be based on some set of inputs. In this case, it is fairly simple, but you can imagine much more complex trees of nested if/else loops.

\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]
if counter == 50:
  # It should at this point!
  print "50!"
else:
  print "Error!"
\end{lstlisting}
  
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]
if counter == 50 * 10**3:
  print "Checks out -- done!"
  print "Final counter =", counter
else:
  sys.exit("Fail!")
\end{lstlisting}

These logical operators can be nested together with loops using \lstinline{for} and \lstinline{while} to generate more complex sets of expressions. For example, you could say that while one value is true, if another value is less than five, you multiply it by five. While there would probably be no reason to ever execute this simple example, it is possible to imagine another case -- in which each pass through a \lstinline{for} loop was one step in time, and then you would change the position of rock units \lstinline{if} a condition for fault slip has been met. And then, for example, you would reset the fault-slip condition so it could accumulate strain before the next earthquake. While fault slip and interseismic strain are complex topics, not accurately represented in such a simple model, it is possible to imagine this approach as a way to accomplish many tasks when programming.

If you want to string together multiple conditions for something there are two options. Either you can create multiple nested \lstinline{if}/\lstinline{else} loops, or you can (usually more efficiently) use statements like \lstinline{and}, \lstinline{or}, and \lstinline{not} to combine conditions. You can think of \lstinline{and} like multiplication: if one is \lstinline{True} (1) and the other is \lstinline{False} (0), then the outcome is \lstinline{False}. Likewise, \lstinline{or} is a bit like addition in that so long as at least one condition is \lstinline{True} (1), then the sum will be $>0$. This is \emph{like} addition in that the result of many \lstinline{or} statements will never be $>1$. I mention this because it is also possible to have multiple variables with mathematical operators, such as addition and multiplication, that tell the computer whether or not to execute an if-statement. An important note is that negative values are also \lstinline{False}. This can be quite useful when writing numerical models in which the sign of a value, or its being nonzero, determines what the model should do. \lstinline{not} returns \lstinline{True} when the statement that it is evaluating is \lstinline{False}.

\subsection{Exceptions: try and except}

You may use \lstinline{try} and \lstinline{except} in a way that is similar to the logical operators. This takes an action that you knnow might fail in the \lstinline{try} portion, and instead of crashing the code, ``catches'' it and moves on to the \lstinline{except} portion.

\begin{framed}
 See pages 162-163 (Downey)
\end{framed}

\subsection{``Print'' and other statements}

\begin{framed}
See Downey, p. 15
\end{framed}

\lstinline{print} sends the output to the screen. Try it! You can print several things on the same line by separating them with commans, as is accomplished in the second line of the above code, reproduced here:
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]
  print "Checks out -- done!"
  print "Final counter =", counter
\end{lstlisting}
  
\subsection{Operators: Mathematical and String}
\label{s:math}

\begin{framed}
See Downey, p. 16, 18
\end{framed}

\begin{table}[!h]
\scriptsize
\begin{tabular}{clll}
Operator	& Numbers			& Strings (and lists)							& Booleans \\
\hline
$+$		& Addition			& Concatenation								&	OR 							\\
		& $1.5 + 3 \rightarrow 4$	& \lstinline{'cow' + 's'} $\rightarrow$ \lstinline{'cows'}		& \lstinline{bool(True + False)} $\rightarrow$ \lstinline{True} \\
		& 				& \lstinline{[1, 2] + ['cow']} $\rightarrow$ \lstinline{[1, 2, 'cow']}	& 								\\
$-$		& Subtraction			&									& 	NOT (XOR)						\\
		& $1.5 - 3 \rightarrow -1.5$	& 									& \lstinline{bool(True - False)} $\rightarrow$ \lstinline{True} \\
$*$		& Multiplication		& Repetition								& 	AND							\\
		& $1.5 - 3 \rightarrow -1.5$	& \lstinline{'cow' * 2} $\rightarrow$ \lstinline{'cowcow'}		& \lstinline{bool(True * False)} $\rightarrow$ \lstinline{False} \\
		& 				& \lstinline{[1, 2] * 2} $\rightarrow$ \lstinline{[1, 2, 1, 2]}		& 								\\
$/$		& Division			& 									& 								\\
		& Division			& 									& 								\\
$**$		& Exponentiation		& 									& 								\\
		& $3**2 \rightarrow 9$		& 									& 								\\
$\%$		& Modulus (remainder)		& 									& 								\\
		& $15 \% 4 \rightarrow 3$	& 									& 								
\end{tabular}
\caption{Common operators.}
\end{table}

Operators work on numbers how you would expect; please see Downey about how they work with strings (or just experiment!). Also, note this code from above with regard to variable type:
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]
print "Now let's divide counter by 25001, just over half"
print counter/25001

print "Now let's divide counter by 25001., just over half"
print counter/25001.
\end{lstlisting}
When an integer is divided by another integer, the code always rounds down. When there is a floating point number involved, it then gives a more exact solution.

\subsection{Types that combine several items, 1: lists, (dictionaries), tuples}
\label{s:containerTypes}

\begin{framed}
See Downey, Chapters 10: Lists, 11: Dictionaries, and 12: Tuples
\end{framed}

\lstinline{int}, \lstinline{float}, \lstinline{bool}, and \lstinline{str} are four common possible \textbf{types} that single values may have. But these single values may be nested within structures with more complexity. One example of these is a \lstinline{list}. Another is a \lstinline{tuple}. They differ primarily in that items inside lists may be changed, while those inside tuples may not be. Lists and tuples are indexed starting with 0, and these indices are placed within brackets when selecting values. They may contain a mix of variable types. This is a lot to take in in a fairly dense paragraph, so I will really point you to three (!) book chapters, and use the following code example to show some important pieces in working with them:

This provides an example of usage
\begin{lstlisting}
l = [1, 2, 3, 4, 5] # list
t = (1, 2, 3, 4)    # tuple

# You index starting at 0
print l[0] # it is 1!

# Indices that are negative give you values starting from the end!
print t[-1]

# You use a colon to indicate multiple indices
# This is INCLUSIVE of the first value but EXCLUSIVE of the second value!
print l[0:2] # you get 0 and 1
# If you do not have a value before or after the colon, it is assumed
# that you want all values before or after the one that you have listed
print l[:3]
print t[-2:]
print t[:]
print t, "Is the same as the printout right above!"

# Tuples and lists may contain multiple variable types
l2 = [1, 2.16, True, 'Cow']
t2 = [1, 5., False, 'Duck']

# Tuples are immutable: you may not change their values. But lists are not.
print "In a list, a Cow can change to a Duck"
print l2
print "Abra cadabra!"
l2[-1] = 'Duck'
print l2

print "But in a Tuple, we can't change 'Duck' to 'Cow' -- or anything!"
print t2
print "Abra cadabra!"
try:
  t2[-1] = 'Cow'
except:
  print 'Magic trick failed!' # Single and double quotes both define strings
  
# Lists can be concatenated with "+", just like strings
print l + l2

# And can be repeated with "*", just like strings.
print l*3

# If you have a value that changes with time
# and you want to record how it changes,
# you can use the list "Append" command to expand a list
dogs_at_park = [] # empty list
for i in range(5):
  j = i**2
  dogs_at_park.append(j)
print "The number of dogs at the park is growing quadratically!"

# When you are just using values, variables capture the value
# (i.e. make a copy of it)
# and that stays the same no matter what happens to the original
a = 5
b = a
a -= 1
print 'a = ', a, '; b =',  b, ": they are different if you change a scalar"

# But varibales just point to a reference to containers for variables like lists.
# Hence, values are shared
a = [5]
b = a
a[0] -= 1
print 'a =', a, '; b =', b
print "for lists, a and b change in tandem!"
\end{lstlisting}

Dictionaries are very useful, but will not be discussed here, beyond noting that they connect keyword--value pairs. Please read Chapter 11 in Downey's book to learn more about them.

\subsection{Python modules}

I mentioned Python modules briefy above; a module is a set of functions and/or variables that can be useful for a specific task. Python comes with a number of standard modules that assist with certain tasks. These include:
\begin{itemize}
 \item \lstinline{os}: Operating system-related tools
 \item \lstinline{sys}: Access to some Python interpreter objects (objects are containers of functions and/or variables, and will be introduced later)
 \item \lstinline{glob}: Pattern-matching, e.g., for listing files in directories
 \item \lstinline{re}: Regular expressions (regex) for advanced pattern-matching; often helps to format messy data files (for a description of regex, see \url{https://en.wikipedia.org/wiki/Regular_expression})
\end{itemize}

Other useful modules that you should have installed (and you should now if you haven't) include:
\begin{itemize}
 \item \lstinline{scipy}: Special functions, solvers, mathematical tools
 \item \lstinline{numpy}: Arrays and matrices, more mathematical tools (see \ref{s:numpy} below for more information)
 \item \lstinline{matplotlib}: Plotting and graphics
\end{itemize}


Modules are imported at the beginning of your script as follows:
\begin{lstlisting}[belowskip=-1.6\baselineskip, language=python]
import os # Import it just as "os"

print "our current directory is:"
print os.getcwd()

from os import path # imports one part of a module

print "We can check if the current working directory is a directory,"
print "which of course it is."
print path.isdir(os.getcwd())
print "And we can do it with "os" alone, because "path" is part of os.
print os.path.isdir(os.getcwd())

import numpy as np # Use "np." instead of "numpy." before commands

from matplotlib import pyplot as plt # combination -- pyplot is plt, but base
                                     # matplotlib is not imported
\end{lstlisting}

\subsection{Numpy, namespaces, and numpy arrays}
\label{s:numpy}

``Numpy'', which stands for ``Numerical Python'', is a module that we will use quite often. To import it at the start of a script, we write:
\begin{lstlisting}
import numpy as np
\end{lstlisting}
The ``as np'' portion of this means that we have only to write ``np.'' before any numpy command or variable instead of ``numpy.''. For example:
\begin{lstlisting}
import numpy as np

print np.pi
print np.e
\end{lstlisting}

One could also write:
\begin{lstlisting}
from numpy import *

print pi
print e
\end{lstlisting}
and forego all of the ``np.*'' alltogether. However, let's say that you forget that ``e'' is a special character and decide you want it to be the number of electroncs in your sample.
\begin{lstlisting}
from numpy import *

e = 5128

print pi
print e
print "Oh, no! We lost Euler"
\end{lstlisting}
This is an introduction to a very important concept, which is protecting \textbf{namespaces} so you do not accidentally ovewrite functions or variables. 

To learn about Numpy, there are major resources.

\begin{enumerate}
 \item There is a really nice tutorial at \url{http://wiki.scipy.org/Tentative_NumPy_Tutorial}
 \item For those of you familiar with Matlab, there is a chart of equivalent functions, operators, etc. at \url{http://mathesaurus.sourceforge.net/matlab-numpy.html}.
\end{enumerate}

You should become familiar with numpy arrays, as they will become the basis for much of what we do in this class!

\subsection{Plotting values}

Plotting doesn't exactly fall into ``standard'' programming -- but hey, you'll be doing scientific programming, and it is important! The great thing about being able to write computer scripts that generate plots is that if your data change or if you want to do something different, you don't have to start from nothing. Plus, those generated by Python's module, Matplotlib, look so much nicer than any default Excel plot.

To learn how to use Matplotlib, see the online tutorial at \url{http://matplotlib.org/users/pyplot_tutorial.html}.

\section{Writing programs}

All right! You finished the basics. Or you skipped them. Whatever, either way you're ready to start writing computer programs. That is great.

First-off, you should know that there are two general programming paradigms.
\begin{itemize}
 \item \textbf{Imperative} programs list a set of commands in order. These may include \textbf{functions}, pieces of code that take an input and return an output
 \item \textbf{Object-oriented} programs combine variables and functions into ``objects'', which are then instantiated (created as a unique copy with specific attributes) and executed (run) by other code.
\end{itemize}

We are going to use the example of a horizontally-thrown snowball to learn about how to write code like this. It outputs its maximum distance and horizontal impact momentum.

\subsection{Imperative}

\subsubsection{Without functions}

\lstinputlisting{code/Introduction/snowball_imperative.py}

\subsubsection{With functions}

\begin{framed}
For more on functions, see Downey, Chapters 3 and 4.
\end{framed}

Here and beyond, one can use the functions to simply produce several outputs based on some inputs without copying and pasting the entire code.

\lstinputlisting{code/Introduction/snowball_imperative_functions.py}

\subsubsection{Placing these functions in a module by themselves}

\begin{framed}
For more on custom modules, see Downey, pp. 166--167
\end{framed}

Module:
\lstinputlisting{code/Introduction/snowball_functions_module.py}

Driver:
\lstinputlisting{code/Introduction/snowball_functions_module_driver.py}

\subsection{Object-oriented}

\begin{framed}
For quite a lot more about objects, see Downey, Chapters 15--18
\end{framed}

We could have the class held in the same file or in a separate file. Because you already have experience with things being in different files from the above module import, we will introduce classes in a separate file. Pay attention to the comments as well as the docstrings (the latter are between two lines of \lstinline{"""}), as they help you to understand how the classes work.

In short, a ``class'' is a concept -- think of it as a generic Lego set sitting on a shelf. There are infinite Lego sets. But when you ``instantiate'' one, you make it yours, and give it properties. To return to the snowball example, you can give it properties like density and horizontal release velocity that effect the output -- the distance it can be thrown (based on ballistics without air drag) and the impact momentum. So your Lego set, your snowball, your whatever -- they are your personalized version of this class.

A class is instantiated as follows:
\begin{lstlisting}
import snowball
myfluffball = snowball.snowball()
\end{lstlisting}
Then you can type \lstinline{myfluffball.} inside iPython and press ``tab'' twice to see the contents of the class -- variables and functions.

Variables within the class belong to the class, and as default contain \lstinline{self.} in front of them (within the class) and the name of the instance when used outside of the class itself.

Module with class:
\lstinputlisting{code/Introduction/snowball.py}

Driver:
\lstinputlisting{code/Introduction/mysnowball.py}

This concept becomes quite powerful when it can be applied to something like your Earth-science model or data analysis routine, in that it allows flexible reproducibility of your work.

\section{Code philosophy}

At this point, you know enough that I want to share a few points that I hold closely when writing computer code:

\begin{itemize}
 \item Write something you care about.
 \item Reproducable results -- you want to produce something that will work consistently. And sometimes this means that you need to be careful when coding!
 \item Keep the inputs separate from what runs the code. Having a module with a class that does the heavy lifting is a great way to do this; see the snowball class example, above.
 \item Generalized: change variables in a central place, don't have to change multiple values (have one master vlaue that is referenced), etc.
 \item But don't spend so much time making a single-use code perfect that you are wasting time... unless your goal is to learn how to write a really nice code!
 \item Know when to make a tactical retreat -- don't stare at the computer trying random combinations of solutions. Leave, do something else, take a walk, do other work, ask a friend for help. These all help you avoid the computer black hole.
\end{itemize}

\section{Version control}

When we are in the lab or in the field, we keep notebooks of important steps along the way so we can track our path through the work and share our work with others. When producing software, we want the same things. Therefore, computer scientists have built ``version control'' tools. These track changes you have made to your code by leaving bookmarks where you have ``committed'' the code, and help you to collaborate with others and manage release versions of your code.

We can learn about version-control tools by interfacing with our course's own GitHub site. GitHub, uses ``git'', pronounced the same as ``get''. I could write a lot about it here, but it's been done before. So just go to this link and follow the help:

\url{http://git-scm.com/doc}

And if you prefer a video to describe some of this, well, this one seems okay:

\url{https://www.youtube.com/watch?v=0fKg7e37bQE}

Once you have done this, I challenge you to ``clone'' a copy of the course notes onto your home computer using the \lstinline{git clone <url>} command. You can then use \lstinline{git pull} to continually update your version of all of the course documentation.

You are of course not required to post your code on github or to create an account. But if you do wish to work with git, it is good practice, wheher your are interested in academia or industry. And it can provide me a good way of helping you with your projects by creating a ``fork'' of what you have done (think of this as a fork in the road by which one set of code takes one path, and one takes another), making some changes, and then requesting to merge my fork back in with yours. (If you do not use git, we can still do this over email.) You can also use git to help each other with your projects. And this is really one main power of git and version-control in general: it streamlines collaboration.

\section{An example model: random-walk diffusion}

This last example is something we can go through as a class. I challenge you to use the concepts you have learned about writing good code to improve upon this -- consider how to make plotting less repetative, bundle the code into sections, and perhaps make it into a set of functions with inputs and outputs -- or even a class (object).

\lstinputlisting{code/Introduction/randomWalk1D_before_class.py}

\end{document}
